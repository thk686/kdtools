<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Compact multidimensional sorting and searching with kdtools â€¢ kdtools</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">kdtools</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/kdtools.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/thk686/kdtools">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Compact multidimensional sorting and searching with kdtools</h1>
                        <h4 class="author">Timothy H. Keitt</h4>
            
            <h4 class="date">2018-03-18</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>Sorting and searching are fundamental operations in computer and data science. The objective of the <code>kdtools</code> is to expose a C++ header file implementing efficient sorting and searching methods for multidimensional tuple-like data. The interface mirrors that of the <a href="http://en.cppreference.com/w/">C++ Standard Template Library (STL)</a> sorting and searching functions.</p>
<p>A common approach to improving search performance is to place data into an ordered tree structure, the most common being a binary tree and its variants. Computer textbooks and introductory courses are littered with examples of tree structures, however it <a href="http://scottmeyers.blogspot.com/2015/09/should-you-be-using-something-instead.html">has been pointed out by practitioners</a> that many tree-type data structures have considerable storage overhead and poor memory locality. This results from using linked-list-like pointers to connect nodes. In many cases, a fully or partially sorted sequence combined with binary search will outperform pointer-based trees. Indeed, <a href="http://en.cppreference.com/w/cpp/algorithm">the STL contains a set of algorithms</a> for sorting or partitioning a data sequence and searching within partitioned sequences.</p>
<p>A limitation of the STL algorithms and data structures is that they can only be ordered in a single dimension. Sort keys can possess higher cardinality however comparison operators and ordering are unidimensional. This is suboptimal for data that are intrinsically multidimensional, such as geographical coordinates or other multivariate data. In multiple dimensions, it is preferred to order a sequence of keys such the average distance between neighboring pairs in the sequence is small. There exist a vast array of techniques to accomplish sequence localization; however I will only discuss one known as the <a href="https://en.wikipedia.org/wiki/K-d_tree">kd-tree</a>.</p>
<p>A kd-tree is a type of binary tree that cycles among the dimensions of its stored objects at each level of the tree hierarchy. In the case of spatial data, the root node will contain the median key in the x-direction and each of its daughter nodes will contain the median in the y-direction of their respective partitions. Subsequent daughter nodes will again contain medians in the x-direction, and so on until there are no additional keys to the left or right. Searching a kd-tree involves recursive comparisons, cycling among the dimensions, until a leaf-node is encountered. Most searching operations can be accomplished in logarithmic time complexity yielding an efficient method.</p>
<p>Precisely as an ordinary binary tree can be replaced by a sorted range, a sequence of multidimensional elements can be sorted, in-place if desired, via recursive partitioning following the kd-tree scheme. Divide-and-conquer recursive partitioning is a well-known sorting algorithm and is the basis of the <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort algorithm</a>. Partitioning a sequence places all elements less than (or more generally meeting some predicate) to the left of a selected key, while all elements greater-than-or-equal-to follow to the right. The kd-sort algorithm presented here simply modifies quicksort to cycle among the dimensions of the stored elements. Searching follows exactly as the kd-tree except that nodes correspond to pivot-elements in the linear array.</p>
<p>Implementation of <code>kd_sort</code> enables a set of additional algorithms for searching and nearest neighbor queries. The following table gives the exposed functions and corresponding STL routines.</p>
<table style="width:97%;" class="table">
<colgroup>
<col width="25%">
<col width="20%">
<col width="51%">
</colgroup>
<thead><tr class="header">
<th>Function templates</th>
<th>STL analog</th>
<th>Outcome</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>kd_sort</td>
<td>sort</td>
<td>sorts range</td>
</tr>
<tr class="even">
<td>kd_is_sorted</td>
<td>is_sorted</td>
<td>returns <code>true</code> if sorted</td>
</tr>
<tr class="odd">
<td>kd_lower_bound</td>
<td>lower_bound</td>
<td>finds first element not less than key for all dimensions</td>
</tr>
<tr class="even">
<td>kd_upper_bound</td>
<td>upper_bound</td>
<td>finds first element greater than key for all dimensions</td>
</tr>
<tr class="odd">
<td>kd_binary_search</td>
<td>binary_search</td>
<td>returns true if key exists in range</td>
</tr>
<tr class="even">
<td>kd_equal_range</td>
<td>equal_range</td>
<td>returns an iterator pair spanning all occurrences of a key</td>
</tr>
<tr class="odd">
<td>kd_range_query</td>
<td>lower_bound, upper_bound</td>
<td>finds all elements not less than lower and less than upper</td>
</tr>
<tr class="even">
<td>kd_nearest_neighbor</td>
<td></td>
<td>finds nearest neighbor of key</td>
</tr>
<tr class="odd">
<td>kd_nearest_neighbors</td>
<td></td>
<td>finds k-nearest neighbors of key</td>
</tr>
<tr class="even">
<td>lex_sort</td>
<td></td>
<td>ordinary STL sort using kd_less for comparison</td>
</tr>
</tbody>
</table>
</div>
<div id="sorting" class="section level2">
<h2 class="hasAnchor">
<a href="#sorting" class="anchor"></a>Sorting</h2>
<p>The kd-sort algorithm in the kdtools package is implemented as a C++ function template parameterized by the starting dimension (usually 0) and the iterator type, which will be auto-deduced by the compiler.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="kw">typename</span> Iter&gt;
<span class="dt">void</span> kd_sort(Iter first, Iter last)
{
  <span class="kw">using</span> TupleType = <span class="dt">iter_value_t</span>&lt;Iter&gt;;
  <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;::value;
  <span class="cf">if</span> (distance(first, last) &gt; <span class="dv">1</span>)
  {
    <span class="kw">auto</span> pred = kd_less&lt;I&gt;();
    <span class="kw">auto</span> pivot = middle_of(first, last);
    nth_element(first, pivot, last, pred);
    pivot = adjust_pivot(first, pivot, pred);
    kd_sort&lt;J&gt;(next(pivot), last);
    kd_sort&lt;J&gt;(first, pivot);
  }
}</code></pre></div>
<p>The code utilizes the <a href="http://en.cppreference.com/w/cpp/algorithm/nth_element"><code>nth_element</code></a> function from the STL. The <code>nth_element</code> algorithm partially sorts a range such that the element pointed to by the pivot iterator is the one that would be in that position if the range was fully sorted. Since the pivot is chosen as the middle element, after calling <code>nth_element</code>, it points to the median key. The <code>nth_element</code> algorithm furthermore partitions the data such that all of the elements to the right of the pivot are not-less-than elements to the left. This is sufficient to recursively sort the range, however it will fail when there are enough ties that the first instance of the median key falls to the left of the pivot. A second partitioning pass, <code>adjust_pivot</code> is therefore required to ensure the pivot points to the first occurrence of the median key in the sequence. Adjust_pivot is thin wrapper around the <a href="http://en.cppreference.com/w/cpp/algorithm/partition"><code>partition</code></a> algorithm from the STL.</p>
<p>Once the first dimension is partitioned, the ranges right and left of the pivot are partitioned, and so on until first and last span a single or no value. The dimension index <code>I</code> is incremented at compile-time using template metaprogramming. The <code>value</code> member of the templated struct <code>next_dim</code> holds the incremented value of <code>I</code> that has been wrapped to cycle through successive dimensions of <code>TupleType</code>. The result of <code>kd_sort</code> is a sequence ordered as if it were inserted into a kd-tree data structure. The following figure illustrates the resulting order in 2-dimensions.</p>
<p><img src="kdtools_files/figure-html/unnamed-chunk-2-1.png" width="576"></p>
<p>Here the sequence order is shown with a continuous color gradient. The resulting patchiness indicates a hierarchical tree-like partitioning of the space providing the desired locality. Placing nearby points in proximity is what allows for efficient searches once the data are sorted. Sort times for vectors of tuple-like objects are relatively efficient, taking roughly twice the time of an ordinary lexicographical sort.</p>
<p><img src="kdtools_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>In the above results, <code>lex_sort</code> is the STL built-in <a href="http://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a> algorithm using <code>kd_less</code> as the predicate. The results indicate that <code>kd_sort</code> is reasonably fast, requiring roughly twice the time as the STL built-in sorting algorithm. Because of the divide-and-conquer nature of <code>kd_sort</code>, it is trivially parallelizable. The threaded version is equal to or faster than the regular sort. Performance comparable to the build-in STL <code>sort</code> function indicates that this reference implementation is reasonable. The computational complexity appears to scale linearly in the number of tuples in all cases.</p>
<div id="multidimensional-comparisons" class="section level3">
<h3 class="hasAnchor">
<a href="#multidimensional-comparisons" class="anchor"></a>Multidimensional comparisons</h3>
<p>To ensure the correct behavior in the presence of multiple ties, or even when all keys in one dimension are equal, the <code>kd_less</code> predicate implements circular lexicographic comparison. If elements in one dimension are tied, the next dimension is interrogated to break the tie. The comparisons cycle from trailing dimensions to leading dimensions using modulo arithmetic. It is implemented as a recursive, templated function object with the dimension index incremented at compile-time. SFINAE is used to stop the compile-time iteration after <a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_size"><code>tuple_size&lt;TupleType&gt;::value</code></a> steps. The could be simplified using <a href="http://en.cppreference.com/w/cpp/utility/apply"><code>std::apply</code></a> or <a href="http://en.cppreference.com/w/cpp/language/if">constexpr-if</a> from C++17.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="dt">size_t</span> K = <span class="dv">0</span>&gt;
<span class="kw">struct</span> kd_less
{
  <span class="kw">template</span> &lt;<span class="kw">typename</span> TupleType&gt;
  <span class="kw">typename</span> enable_if&lt;is_not_last&lt;K, TupleType&gt;::value, <span class="dt">bool</span>&gt;::type
  <span class="kw">operator</span>()(<span class="at">const</span> TupleType&amp; lhs, <span class="at">const</span> TupleType&amp; rhs) <span class="at">const</span>
  {
    <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;::value;
    <span class="cf">return</span> get&lt;I&gt;(lhs) == get&lt;I&gt;(rhs) ?
      kd_less&lt;J, K + <span class="dv">1</span>&gt;()(lhs, rhs) :
        get&lt;I&gt;(lhs) &lt; get&lt;I&gt;(rhs);
  }
  <span class="kw">template</span> &lt;<span class="kw">typename</span> TupleType&gt;
  <span class="kw">typename</span> enable_if&lt;is_last&lt;K, TupleType&gt;::value, <span class="dt">bool</span>&gt;::type
  <span class="kw">operator</span>()(<span class="at">const</span> TupleType&amp; lhs, <span class="at">const</span> TupleType&amp; rhs) <span class="at">const</span>
  {
    <span class="cf">return</span> get&lt;I&gt;(lhs) &lt; get&lt;I&gt;(rhs);
  }
};</code></pre></div>
<p>A more general function object template <code>kd_compare</code> that takes an arbitrary binary predicate is also provided by <code>kdtools</code>. Some examples applying <code>kd_less</code>, including degenerate, all-ties cases, are shown here.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">j =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>))
k =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>))
<span class="kw">t</span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(j))</code></pre></div>
<table class="table"><tbody><tr class="odd">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr></tbody></table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">t</span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw">cbind</span>(j, k)))</code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">4</td>
<td align="right">3</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">8</td>
<td align="right">9</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">5</td>
<td align="right">8</td>
<td align="right">9</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">7</td>
</tr>
</tbody></table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">t</span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw">cbind</span>(<span class="dv">0</span>, j, k)))</code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">6</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">5</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">7</td>
<td align="right">3</td>
<td align="right">4</td>
</tr>
</tbody></table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">t</span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw">cbind</span>(j, k, <span class="dv">0</span>)))</code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">4</td>
<td align="right">3</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">8</td>
<td align="right">9</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">5</td>
<td align="right">8</td>
<td align="right">9</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">7</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody></table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">t</span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw">cbind</span>(<span class="dv">0</span>, j, <span class="dv">0</span>)))</code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody></table>
<p>Notice that <code>kd_sort</code> falls-back to the quicksort algorithm in one dimension. It also is not effected by all-ties. The order of subsequent dimensions can be changed when the leading dimension contains all ties, however the sequence is still sorted and can be used for searching.</p>
</div>
<div id="searching" class="section level3">
<h3 class="hasAnchor">
<a href="#searching" class="anchor"></a>Searching</h3>
<p>Once data are ordered appropriately, searching can be achieved efficiently. The <code>kdtools</code> package provides analogs of the STL <code>lower_bound</code>, <code>upper_bound</code>, <code>equal_range</code> and <code>binary_search</code> functions for querying sorted ranges. An additional function, <code>kd_range_query</code>, does efficient searching within a boxed region.</p>
<p>The <code>kd_lower_bound</code>, <code>kd_upper_bound</code> and <code>kd_equal_range</code> algorithms behave differently than their unidimensional analogs. This is because the only reasonable definition of multidimensional less is to require less in all dimensions simultaneously. As illustrated below, this leads to cases where some, but not all, elements are less to be included in the interval spanned by <code>kd_lower_bound</code>, <code>kd_upper_bound</code> and <code>kd_equal_range</code>. In other words, in a single dimension, these routines are both necessary and sufficient, whereas in multiple-dimensions, they are necessary, but not sufficient to uniquely identify elements in a boxed region.</p>
<p>In other schemes, such as <a href="https://en.wikipedia.org/wiki/Z-order_curve">Morton codes</a>, elaborate subroutines are required to prune the extra elements falling outside the region of interest (see lower-left panel below). This is a result of using a fundamentally unidimensional search on multidimensional data. Instead <code>kd_sort</code> implements direct binary search for points falling within a boxed region.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I,
          <span class="kw">typename</span> Iter,
          <span class="kw">typename</span> TupleType,
          <span class="kw">typename</span> OutIter&gt;
<span class="dt">void</span> kd_range_query(Iter first, Iter last,
                    <span class="at">const</span> TupleType&amp; lower,
                    <span class="at">const</span> TupleType&amp; upper,
                    OutIter outp)
{
  <span class="cf">if</span> (distance(first, last) &gt; <span class="dv">32</span>) {
    <span class="kw">auto</span> pred = less_nth&lt;I&gt;();
    <span class="kw">auto</span> pivot = find_pivot&lt;I&gt;(first, last);
    <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;::value;
    <span class="cf">if</span> (within(*pivot, lower, upper)) *outp++ = *pivot;
    <span class="cf">if</span> (!pred(*pivot, lower)) <span class="co">// search left</span>
      kd_range_query&lt;J&gt;(first, pivot, lower, upper, outp);
    <span class="cf">if</span> (pred(*pivot, upper)) <span class="co">// search right</span>
      kd_range_query&lt;J&gt;(next(pivot), last, lower, upper, outp);
  } <span class="cf">else</span> {
    copy_if(first, last, outp, [&amp;](<span class="at">const</span> TupleType&amp; x){
      <span class="cf">return</span> within(x, lower, upper);
    });
  }
  <span class="cf">return</span>;
}</code></pre></div>
<p>Here, each pivot element is tested to see whether it falls within the boxed region, in which case, it is assigned to the output iterator. The template <code>find_pivot</code> searches for the partition point whose position may or may not be the middle of the sequence. Leaf tuples are also tested and copied to the output iterator. We check in each dimension whether there might be additional points in the region of interest to the left or right in the array. These are searched recursively until reaching a leaf. In the following plot, the blue points indicate those not meeting the predicate and the aquamarine points are those where the predicate returns true.</p>
<p><img src="kdtools_files/figure-html/unnamed-chunk-9-1.png" width="480"></p>
</div>
<div id="performance-comparison-to-boost-geometry" class="section level3">
<h3 class="hasAnchor">
<a href="#performance-comparison-to-boost-geometry" class="anchor"></a>Performance comparison to Boost Geometry</h3>
<p>The <a href="http://www.boost.org/doc/libs/release/libs/geometry/">Boost Geometry library</a> is a highly sophisticated and performant framework for working with geometric features. It includes an <a href="https://en.wikipedia.org/wiki/R-tree">R-Tree index</a> that allows access to objects within a bounding region in logarithmic time. Here I compare the speed of building and querying a collection of points. The only purpose of this comparison is to look for large (i.e., 5 to 10 fold) differences, which would indicate a problem in the implementation. Small differences in measured times are probably not meaningful and will likely change on different systems. Reported results are the median of 21 trials using 1e7 tuples.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_sort inplace</td>
<td align="right">3.52</td>
<td align="right">1.00</td>
</tr>
<tr class="even">
<td align="left">kd_sort w/ copy</td>
<td align="right">3.66</td>
<td align="right">1.00</td>
</tr>
<tr class="odd">
<td align="left">kd_sort_threaded</td>
<td align="right">1.66</td>
<td align="right">0.47</td>
</tr>
<tr class="even">
<td align="left">rtree pack linear</td>
<td align="right">4.11</td>
<td align="right">1.20</td>
</tr>
<tr class="odd">
<td align="left">rtree pack quadratic</td>
<td align="right">4.08</td>
<td align="right">1.20</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_range_query</td>
<td align="right">0.000832</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree query linear</td>
<td align="right">0.002590</td>
<td align="right">3.1</td>
</tr>
<tr class="odd">
<td align="left">rtree query quadratic</td>
<td align="right">0.002680</td>
<td align="right">3.2</td>
</tr>
</tbody>
</table>
<p>The results indicate that sorting and searching with kdtools is at least as performant as using Boost Geometry. Generally, an R-Tree will have an advantage with many individual insertions and deletions, whereas a sorted range will be more compact and show equal, if not better, query performance.</p>
<div id="nearest-neighbor-search" class="section level4">
<h4 class="hasAnchor">
<a href="#nearest-neighbor-search" class="anchor"></a>Nearest-neighbor search</h4>
<p>The kdtools package also provides routines for nearest- and k-nearest- neighbor search.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_nearest_neighbor</td>
<td align="right">7.80e-06</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree nearest neighbor linear</td>
<td align="right">4.82e-05</td>
<td align="right">6.2</td>
</tr>
<tr class="odd">
<td align="left">rtree nearest neighbor quadratic</td>
<td align="right">1.38e-05</td>
<td align="right">1.8</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_nearest_neighbors 100</td>
<td align="right">3.85e-05</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree nearest 100 linear</td>
<td align="right">1.32e-04</td>
<td align="right">3.4</td>
</tr>
<tr class="odd">
<td align="left">rtree nearest 100 quadratic</td>
<td align="right">1.01e-04</td>
<td align="right">2.6</td>
</tr>
</tbody>
</table>
<p>As before, the results show kdtools to be as fast or faster than Boost Geometry search. This is not surprising as the R-Tree data structure is optimized for indexing boxed regions, not points. The main conclusion here is that the current implementation of kdtools is reasonably efficient.</p>
</div>
</div>
<div id="mixed-type-searches" class="section level3">
<h3 class="hasAnchor">
<a href="#mixed-type-searches" class="anchor"></a>Mixed-type searches</h3>
<p>Notice that the only requirement of the algorithms is that the <code>get&lt;I&gt;</code> function return an object meeting the <a href="http://en.cppreference.com/w/cpp/concept/EqualityComparable">EqualityComparable</a> and <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> C++ concepts. This means that different dimensions can contain different data types, including strings, for example. The current implementation uses <code>std::get</code> and so is restricted to <code>std::pair</code>, <code>std::tuple</code> and <code>std::array</code>, unless one chooses to specializes in the <code>std</code> namespace, which is generally not recommended. A suitable mechanism for providing type-specific specializations is to-be-implemented. The following example demonstrates sorting and searching a container holding keys of type <code>std::tuple&lt;double, std::string&gt;</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(kdtools)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">"mixed_query.h"</span>

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">void</span> mixed_query(NumericVector c1, CharacterVector c2)
{
  <span class="kw">auto</span> n = c1.size();
  
  <span class="dt">range_type</span> data;
  data.reserve(n);
  
  transform(begin(c1), end(c1), begin(c2), back_inserter(data), make_key());
  
  <span class="kw">auto</span> t = time_it([&amp;]{
    
    kd_sort(begin(data), end(data));
    
  });
  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Sort time: "</span> &lt;&lt; t.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;
  
  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last 5 elements of sorted data:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;
  print_range(data);
  
  <span class="dt">range_type</span> result;
  
  <span class="kw">auto</span> u = time_it([&amp;]{
    
    kd_range_query(begin(data), end(data),
                   <span class="dt">key_type</span>(<span class="fl">0.4</span>, <span class="st">"w"</span>), <span class="dt">key_type</span>(<span class="fl">0.6</span>, <span class="st">"z"</span>),
                   back_inserter(result));
    
  });
  
  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Query time: "</span> &lt;&lt; u.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;

  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last 5 elements of query return:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;
  kd_sort(begin(result), end(result)); print_range(result);
  
  result.clear();
  
  <span class="kw">auto</span> v = time_it([&amp;]{
    
    kd_nearest_neighbors(begin(data), end(data),
                         <span class="dt">key_type</span>(<span class="fl">0.5</span>, <span class="st">"kdtools"</span>), <span class="dv">100</span>,
                         back_inserter(result));
    
  });
  
  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Neighbors query time: "</span> &lt;&lt; v.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;

  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last 5 elements of neighbors query return:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;
  kd_sort(begin(result), end(result)); print_range(result);
}</code></pre></div>
<p>First the data are sorted and then a range query is conducted. The range query selects tuples where the first element ranges from <code>0.4</code> to <code>0.6</code> and the second element begins with letters <code>w</code> through <code>y</code>. For the test, we borrow the words from the <code>parts_of_speech</code> dataset from the <code>tidytext</code> package. It contains more than <span class="math inline">\(10^5\)</span> words.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(<span class="st">"parts_of_speech"</span>)
numbers =<span class="st"> </span><span class="kw">runif</span>(<span class="kw">nrow</span>(parts_of_speech))
strings =<span class="st"> </span><span class="kw">sample</span>(<span class="kw">tolower</span>(parts_of_speech[[<span class="dv">1</span>]]))
<span class="kw">mixed_query</span>(<span class="kw">signif</span>(numbers, <span class="dv">4</span>), strings)
<span class="co">#&gt; </span>
<span class="co">#&gt; Sort time: 0.135586 seconds</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; First and last 5 elements of sorted data:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 0 0.0009059 abrazos</span>
<span class="co">#&gt; 1 0.002198 abfarad</span>
<span class="co">#&gt; 2 0.002372 aboriginal</span>
<span class="co">#&gt; 3 0.0007408 accordature</span>
<span class="co">#&gt; 4 4.309e-05 activities</span>
<span class="co">#&gt; ...</span>
<span class="co">#&gt; 208254 0.9981 yesteryear</span>
<span class="co">#&gt; 208255 0.9997 yacov</span>
<span class="co">#&gt; 208256 0.9994 zho</span>
<span class="co">#&gt; 208257 0.9986 zoha</span>
<span class="co">#&gt; 208258 0.9997 zoolatrous</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Query time: 0.00016389 seconds</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; First and last 5 elements of query return:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 0 0.4057 wae</span>
<span class="co">#&gt; 1 0.403 walk-down</span>
<span class="co">#&gt; 2 0.4073 wallop</span>
<span class="co">#&gt; 3 0.4097 wadesworth</span>
<span class="co">#&gt; 4 0.4054 warhorse</span>
<span class="co">#&gt; ...</span>
<span class="co">#&gt; 1108 0.5971 xenocratic</span>
<span class="co">#&gt; 1109 0.5987 yasht</span>
<span class="co">#&gt; 1110 0.5926 yell</span>
<span class="co">#&gt; 1111 0.5935 yuzik</span>
<span class="co">#&gt; 1112 0.595 yha</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Neighbors query time: 0.000777039 seconds</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; First and last 5 elements of neighbors query return:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 0 0.1906 kalathos</span>
<span class="co">#&gt; 1 0.1869 kaleidoscopic</span>
<span class="co">#&gt; 2 0.3525 katalyzed</span>
<span class="co">#&gt; 3 0.4117 isologue</span>
<span class="co">#&gt; 4 0.4134 joust</span>
<span class="co">#&gt; ...</span>
<span class="co">#&gt; 95 0.728 ladinos</span>
<span class="co">#&gt; 96 0.7198 loferski</span>
<span class="co">#&gt; 97 0.7304 lowsest</span>
<span class="co">#&gt; 98 0.7435 lousewort</span>
<span class="co">#&gt; 99 0.7477 lovesome</span></code></pre></div>
<p>The timing results indicate that sorting <span class="math inline">\(2 \times 10 ^ 5\)</span> tuples is on the order of 1/10th second, whereas the range query returned in less than a millisecond.</p>
<p>Nearest neighbor searching requires a suitable distance function be defined for all types. The computation above uses the following definitions.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> InputIt1, <span class="kw">class</span> InputIt2&gt;
<span class="dt">double</span> set_similarity(InputIt1 first1, InputIt1 last1,
                      InputIt2 first2, InputIt2 last2)
{
  <span class="dt">double</span> num = <span class="dv">0</span>, denom = <span class="dv">0</span>;
  <span class="cf">while</span> (first1 != last1 &amp;&amp; first2 != last2) {
    <span class="cf">if</span> (*first1 &lt; *first2) {
      ++first1; ++denom;
    } <span class="cf">else</span> {
      <span class="cf">if</span> (!(*first2 &lt; *first1)) {
        ++first1; ++num;
      }
      ++first2; ++denom;
    }
  }
  denom += <span class="bu">std::</span>distance(first1, last1) + <span class="bu">std::</span>distance(first2, last2);
  <span class="cf">return</span> num / denom;
}

<span class="kw">namespace</span> kdtools {

<span class="kw">template</span> &lt;&gt;
<span class="dt">double</span> scalar_diff(<span class="at">const</span> <span class="bu">std::</span>string&amp; lhs, <span class="at">const</span> <span class="bu">std::</span>string&amp; rhs)
{
  <span class="bu">std::</span>string a(lhs), b(rhs);
  <span class="bu">std::</span>sort(begin(a), end(a));
  <span class="bu">std::</span>sort(begin(b), end(b));
  <span class="cf">return</span> <span class="dv">1</span> - set_similarity(begin(a), end(a),
                            begin(b), end(b));
}

}; <span class="co">// namespace kdtools</span></code></pre></div>
<p>The <code>set_similarity</code> template is adapted from the STL <code>set_intersection</code> template and produces a number between 0 and 1. I have not attempted to prove this distance is metric, so the results may not be entirely correct. Also, there is no facility currently available to weight distances in different dimensions or override the default root-sum-of-squares algorithm for the multivariate distance.</p>
</div>
</div>
<div id="conclusions" class="section level2">
<h2 class="hasAnchor">
<a href="#conclusions" class="anchor"></a>Conclusions</h2>
<p>The kdtools package implements efficient sorting and searching of arbitary tuple-like object in C++. One of the major design decisions was to make the number of dimensions fixed at compile time. This is a reasonable tradeoff as these methods break down in high dimensions where search times will be no better than that of brute-force random searching. Nonetheless, a runtime-dimensioned extension would be easy to add and could allow working with runtime-determined types as is common in R. The current implementation is a demonstration, however it does illustrate the value of the STL as the algorithms are constructed from STL components. The generic nature of the kdtools implementation is an attractive feature as it permits flexibility and can be adapted to arbitrary tuple-like data as needed. Modern development of C++ has emphasized tuple-style data and algorithms and kdtools extends these developments.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#sorting">Sorting</a></li>
      <li><a href="#conclusions">Conclusions</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Timothy Keitt.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
