<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Compact multidimensional sorting and searching with kdtools â€¢ kdtools</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Compact multidimensional sorting and searching with kdtools">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">kdtools</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.4.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/kdtools.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/methods.html">Compact multidimensional sorting and searching with kdtools</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/thk686/kdtools">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Compact multidimensional sorting and searching with kdtools</h1>
                        <h4 class="author">Timothy H. Keitt</h4>
            
            <h4 class="date">2019-08-03</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/thk686/kdtools/blob/master/vignettes/methods.Rmd"><code>vignettes/methods.Rmd</code></a></small>
      <div class="hidden name"><code>methods.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>Sorting and searching are fundamental operations in computer and data science. The objective of the <code>kdtools</code> is to expose a C++ header file implementing efficient sorting and searching methods for multidimensional tuple-like data. The interface mirrors that of the <a href="http://en.cppreference.com/w/">C++ Standard Template Library (STL)</a> sorting and searching functions. It is a single header-only library with no external dependencies other than <code>std</code>.</p>
<p>A common approach to improving search performance is to place data into an ordered tree structure, the most common being a binary tree and its variants. Computer textbooks and introductory courses are littered with examples of tree structures, however it <a href="http://scottmeyers.blogspot.com/2015/09/should-you-be-using-something-instead.html">has been pointed out by practitioners</a> that many tree-type data structures have considerable storage overhead and poor memory locality. This results from using linked-list-like pointers to connect nodes. In many cases, a fully or partially sorted sequence combined with binary search will outperform pointer-based trees. Indeed, <a href="http://en.cppreference.com/w/cpp/algorithm">the STL contains a set of algorithms</a> for sorting or partitioning a data sequence and searching within partitioned sequences.</p>
<p>A limitation of the STL algorithms and data structures is that they can only be ordered in a single dimension. Sort keys can possess higher cardinality however comparison operators and ordering are unidimensional. This is suboptimal for data that are intrinsically multidimensional, such as geographical coordinates or other multivariate data. In multiple dimensions, it is preferred to order a sequence of keys such the average distance between neighboring pairs in the sequence is small. There exist a vast array of techniques to accomplish sequence localization; however I will only discuss one known as the <a href="https://en.wikipedia.org/wiki/K-d_tree">kd-tree</a>.</p>
<p>A kd-tree is a type of binary tree that cycles among the dimensions of its stored objects at each level of the tree hierarchy. In the case of spatial data, the root node will contain the median key in the x-direction and each of its daughter nodes will contain the median in the y-direction of their respective partitions. Subsequent daughter nodes will again contain medians in the x-direction, and so on until there are no additional keys to the left or right. Searching a kd-tree involves recursive comparisons, cycling among the dimensions, until a leaf-node is encountered. Most searching operations can be accomplished in logarithmic time complexity yielding an efficient method.</p>
<p>Precisely as an ordinary binary tree can be replaced by a sorted range, a sequence of multidimensional elements can be sorted, in-place if desired, via recursive partitioning following the kd-tree scheme. Divide-and-conquer recursive partitioning is a well-known sorting algorithm and is the basis of the <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort algorithm</a>. Partitioning a sequence places all elements less than (or more generally meeting some predicate) to the left of a selected key, while all elements greater-than-or-equal-to follow to the right. The kd-sort algorithm presented here simply modifies quicksort to cycle among the dimensions of the stored elements. Searching follows exactly as the kd-tree except that nodes correspond to pivot-elements in the linear array.</p>
<p>Implementation of <code>kd_sort</code> enables a set of additional algorithms for searching and nearest neighbor queries. The following table gives the exposed functions and corresponding STL routines.</p>
<table class="table">
<colgroup>
<col width="25%">
<col width="20%">
<col width="53%">
</colgroup>
<thead><tr class="header">
<th>Function templates</th>
<th>STL analog</th>
<th>Outcome</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>kd_sort</td>
<td>sort</td>
<td>sorts range</td>
</tr>
<tr class="even">
<td>kd_is_sorted</td>
<td>is_sorted</td>
<td>returns <code>true</code> if sorted</td>
</tr>
<tr class="odd">
<td>kd_lower_bound</td>
<td>lower_bound</td>
<td>finds first element not less than key for all dimensions</td>
</tr>
<tr class="even">
<td>kd_upper_bound</td>
<td>upper_bound</td>
<td>finds first element greater than key for all dimensions</td>
</tr>
<tr class="odd">
<td>kd_binary_search</td>
<td>binary_search</td>
<td>returns true if key exists in range</td>
</tr>
<tr class="even">
<td>kd_equal_range</td>
<td>equal_range</td>
<td>returns an iterator pair spanning all occurrences of a key</td>
</tr>
<tr class="odd">
<td>kd_range_query</td>
<td>lower_bound, upper_bound</td>
<td>finds all elements not less than lower and less than upper</td>
</tr>
<tr class="even">
<td>kd_nearest_neighbor</td>
<td></td>
<td>finds nearest neighbor of key</td>
</tr>
<tr class="odd">
<td>kd_nearest_neighbors, kd_nn_indices</td>
<td></td>
<td>finds k-nearest neighbors of key</td>
</tr>
<tr class="even">
<td>lex_sort</td>
<td></td>
<td>ordinary STL sort using kd_less for comparison</td>
</tr>
</tbody>
</table>
</div>
<div id="sorting" class="section level2">
<h2 class="hasAnchor">
<a href="#sorting" class="anchor"></a>Sorting</h2>
<p>The kd-sort algorithm in the kdtools package is implemented as a C++ function template parameterized by the starting dimension (usually 0) and the iterator type, which will be auto-deduced by the compiler.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="kw">typename</span> Iter&gt;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dt">void</span> kd_sort(Iter first, Iter last)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">using</span> TupleType = <span class="dt">iter_value_t</span>&lt;Iter&gt;;</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;::value;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="cf">if</span> (distance(first, last) &gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  {</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="kw">auto</span> pred = kd_less&lt;I&gt;();</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="kw">auto</span> pivot = median_part(first, last, pred);</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    kd_sort&lt;J&gt;(next(pivot), last);</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    kd_sort&lt;J&gt;(first, pivot);</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">}</a></code></pre></div>
<p>The <code>median_part</code> function is a thin wrapper around the <a href="http://en.cppreference.com/w/cpp/algorithm/nth_element"><code>nth_element</code></a> function from the standard library, which is used to find the median value in the current dimension. Once the median is identified, it is passed to the standard library <a href="http://en.cppreference.com/w/cpp/algorithm/partition"><code>partition</code></a> function, which places all values less than the median to the left of the pivot element and all greater-than or equal-to to the right.</p>
<p>Once the first dimension is partitioned, the ranges right and left of the pivot are partitioned, and so on until first and last span a single or no value. The dimension index <code>I</code> is incremented at compile-time using template metaprogramming. The <code>value</code> member of the templated struct <code>next_dim</code> holds the incremented value of <code>I</code> that has been wrapped to cycle through successive dimensions of <code>TupleType</code>. The result of <code>kd_sort</code> is a sequence ordered as if it were inserted into a kd-tree data structure. The following figure illustrates the resulting order in 2-dimensions.</p>
<p><img src="methods_files/figure-html/unnamed-chunk-2-1.png" width="576"></p>
<p>Here the sequence order is shown with a continuous color gradient. The resulting patchiness indicates a hierarchical tree-like partitioning of the space providing the desired locality. Placing nearby points in proximity is what allows for efficient searches once the data are sorted. Sort times for vectors of tuple-like objects are relatively efficient, taking roughly twice the time of an ordinary lexicographical sort.</p>
<p><img src="methods_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>In the above results, <code>lex_sort</code> is the STL built-in <a href="http://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a> algorithm using <code>kd_less</code> as the predicate. The results indicate that <code>kd_sort</code> is reasonably fast, requiring roughly twice the time as the STL built-in sorting algorithm. Because of the divide-and-conquer nature of <code>kd_sort</code>, it is trivially parallelizable. The threaded version is equal to or faster than the regular sort. Performance comparable to the build-in STL <code>sort</code> function indicates that this reference implementation is reasonable. The computational complexity appears to scale linearly in the number of tuples in all cases.</p>
<div id="multidimensional-comparisons" class="section level3">
<h3 class="hasAnchor">
<a href="#multidimensional-comparisons" class="anchor"></a>Multidimensional comparisons</h3>
<p>To ensure the correct behavior in the presence of multiple ties, or even when all keys in one dimension are equal, the <code>kd_less</code> predicate implements circular lexicographic comparison. If elements in one dimension are tied, the next dimension is interrogated to break the tie. The comparisons cycle from trailing dimensions to leading dimensions using modulo arithmetic. It is implemented as a recursive, templated function object with the dimension index incremented at compile-time. SFINAE is used to stop the compile-time iteration after <a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_size"><code>tuple_size&lt;TupleType&gt;::value</code></a> steps. The could be simplified using <a href="http://en.cppreference.com/w/cpp/utility/apply"><code>std::apply</code></a> or <a href="http://en.cppreference.com/w/cpp/language/if">constexpr-if</a> from C++17.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="dt">size_t</span> K = <span class="dv">0</span>&gt;</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">struct</span> kd_less</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="kw">typename</span> enable_if&lt;is_not_last&lt;K, T&gt;::value, <span class="dt">bool</span>&gt;::type</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="kw">operator</span>()(<span class="at">const</span> T&amp; lhs, <span class="at">const</span> T&amp; rhs) <span class="at">const</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  {</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, T&gt;::value;</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    <span class="cf">return</span> equal_nth&lt;I&gt;()(lhs, rhs) ?</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      kd_less&lt;J, K + <span class="dv">1</span>&gt;()(lhs, rhs) :</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        less_nth&lt;I&gt;()(lhs, rhs);</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  <span class="kw">typename</span> enable_if&lt;is_last&lt;K, T&gt;::value, <span class="dt">bool</span>&gt;::type</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  <span class="kw">operator</span>()(<span class="at">const</span> T&amp; lhs, <span class="at">const</span> T&amp; rhs) <span class="at">const</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  {</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    <span class="cf">return</span> less_nth&lt;I&gt;()(lhs, rhs);</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">};</a></code></pre></div>
<p>The predicates <code>equal_nth</code> and <code>less_nth</code> compare the <span class="math inline">\(I^{th}\)</span> element of the tuple. They have specializations for handling pointers to tuple-like object, so all functions can operate on a range over pointers to tuples, allowing arbitrary indexing into the original data.</p>
<p>A more general function object template <code>kd_compare</code> that takes an arbitrary binary predicate is also provided by <code>kdtools</code>. Some examples applying <code>kd_less</code>, including degenerate, all-ties cases, are shown here.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">j =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">cbind</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/sample">sample</a></span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">k =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">cbind</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/sample">sample</a></span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(j))</a></code></pre></div>
<table class="table"><tbody><tr class="odd">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr></tbody></table>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">cbind</a></span>(j, k)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">2</td>
<td align="right">4</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="right">5</td>
<td align="right">4</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
</tbody></table>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">cbind</a></span>(<span class="dv">0</span>, j, k)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">4</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">7</td>
</tr>
</tbody></table>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">cbind</a></span>(j, k, <span class="dv">0</span>)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">2</td>
<td align="right">4</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">6</td>
<td align="right">5</td>
<td align="right">4</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody></table>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">cbind</a></span>(<span class="dv">0</span>, j, <span class="dv">0</span>)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody></table>
<p>Notice that <code>kd_sort</code> is a variant of the quicksort algorithm in one dimension. It also is not effected by all-ties. The order of subsequent dimensions can be changed when the leading dimension contains all ties, however the sequence is still sorted and can be used for searching.</p>
</div>
<div id="searching" class="section level3">
<h3 class="hasAnchor">
<a href="#searching" class="anchor"></a>Searching</h3>
<p>Once data are ordered appropriately, searching can be achieved efficiently. The <code>kdtools</code> package provides analogs of the STL <a href="http://en.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound</code></a>, <a href="http://en.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound</code></a>, <a href="http://en.cppreference.com/w/cpp/algorithm/equal_range"><code>equal_range</code></a> and <a href="http://en.cppreference.com/w/cpp/algorithm/binary_search"><code>binary_search</code></a> functions for querying sorted ranges. An additional function, <code>kd_range_query</code>, does efficient searching within a boxed region.</p>
<p>The <code>kd_lower_bound</code>, <code>kd_upper_bound</code> and <code>kd_equal_range</code> algorithms behave differently than their unidimensional analogs. This is because the only reasonable definition of multidimensional less is to require less in all dimensions simultaneously. As illustrated below, this leads to cases where some, but not all, elements are less to be included in the interval spanned by <code>kd_lower_bound</code>, <code>kd_upper_bound</code> and <code>kd_equal_range</code>. In other words, in a single dimension, these routines are both necessary and sufficient, whereas in multiple-dimensions, they are necessary, but not sufficient to uniquely identify elements in a boxed region.</p>
<p>In other schemes, such as <a href="https://en.wikipedia.org/wiki/Z-order_curve">Morton codes</a>, elaborate subroutines are required to prune the extra elements falling outside the region of interest (see lower-left panel below). This is a result of using a fundamentally unidimensional search on multidimensional data. Instead <code>kd_sort</code> implements direct binary search for points falling within a boxed region.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I,</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">          <span class="kw">typename</span> Iter,</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="kw">typename</span> TupleType,</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="kw">typename</span> OutIter&gt;</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="dt">void</span> kd_range_query(Iter first, Iter last,</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                    <span class="at">const</span> TupleType&amp; lower,</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                    <span class="at">const</span> TupleType&amp; upper,</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                    OutIter outp)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="cf">if</span> (distance(first, last) &gt; <span class="dv">32</span>) {</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">auto</span> pred = less_nth&lt;I&gt;();</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    <span class="kw">auto</span> pivot = find_pivot&lt;I&gt;(first, last);</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;::value;</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    <span class="cf">if</span> (within(*pivot, lower, upper)) *outp++ = *pivot;</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    <span class="cf">if</span> (!pred(*pivot, lower)) <span class="co">// search left</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      kd_range_query&lt;J&gt;(first, pivot, lower, upper, outp);</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="cf">if</span> (pred(*pivot, upper)) <span class="co">// search right</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">      kd_range_query&lt;J&gt;(next(pivot), last, lower, upper, outp);</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    copy_if(first, last, outp, [&amp;](<span class="at">const</span> TupleType&amp; x){</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      <span class="cf">return</span> within(x, lower, upper);</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    });</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">}</a></code></pre></div>
<p>Here, each pivot element is tested to see whether it falls within the boxed region, in which case, it is assigned to the output iterator. The template <code>find_pivot</code> searches for the partition point whose position may or may not be the middle of the sequence. Leaf tuples are also tested and copied to the output iterator. We check in each dimension whether there might be additional points in the region of interest to the left or right in the array. These are searched recursively until reaching the span falls below a threshold and is more profitably searched via sequential scan. In the following plot, the blue points indicate those not meeting the predicate and the aquamarine points are those where the predicate returns true.</p>
<p><img src="methods_files/figure-html/unnamed-chunk-9-1.png" width="480"></p>
</div>
<div id="performance-comparison-to-boost-geometry" class="section level3">
<h3 class="hasAnchor">
<a href="#performance-comparison-to-boost-geometry" class="anchor"></a>Performance comparison to Boost Geometry</h3>
<p>The <a href="http://www.boost.org/doc/libs/release/libs/geometry/">Boost Geometry library</a> is a highly sophisticated and performant framework for working with geometric features. It includes an <a href="https://en.wikipedia.org/wiki/R-tree">R-Tree index</a> that allows access to objects within a bounding region in logarithmic time. Here I compare the speed of building and querying a collection of points. The only purpose of this comparison is to look for large (i.e., 5 to 10 fold) differences, which would indicate a problem in the implementation. Small differences in measured times are probably not meaningful and will likely change on different systems. Reported results are the median of 21 trials using 1e7 tuples.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_sort inplace</td>
<td align="right">3.140</td>
<td align="right">1.00</td>
</tr>
<tr class="even">
<td align="left">kd_sort w/ copy</td>
<td align="right">3.260</td>
<td align="right">1.00</td>
</tr>
<tr class="odd">
<td align="left">kd_sort_threaded</td>
<td align="right">0.511</td>
<td align="right">0.16</td>
</tr>
<tr class="even">
<td align="left">rtree pack linear</td>
<td align="right">3.810</td>
<td align="right">1.20</td>
</tr>
<tr class="odd">
<td align="left">rtree pack quadratic</td>
<td align="right">3.820</td>
<td align="right">1.20</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_range_query</td>
<td align="right">0.00106</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree query linear</td>
<td align="right">0.00339</td>
<td align="right">3.2</td>
</tr>
<tr class="odd">
<td align="left">rtree query quadratic</td>
<td align="right">0.00319</td>
<td align="right">3.0</td>
</tr>
</tbody>
</table>
<p>The results indicate that sorting and searching with kdtools is at least as performant as using Boost Geometry. Generally, an R-Tree will have an advantage with many individual insertions and deletions, whereas a sorted range will be more compact and show equal, if not better, query performance.</p>
<div id="nearest-neighbor-search" class="section level4">
<h4 class="hasAnchor">
<a href="#nearest-neighbor-search" class="anchor"></a>Nearest-neighbor search</h4>
<p>The kdtools package also provides routines for nearest- and k-nearest- neighbor search.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_nearest_neighbor</td>
<td align="right">1.06e-05</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree nearest neighbor linear</td>
<td align="right">5.49e-05</td>
<td align="right">5.2</td>
</tr>
<tr class="odd">
<td align="left">rtree nearest neighbor quadratic</td>
<td align="right">1.74e-05</td>
<td align="right">1.6</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_nearest_neighbors 100</td>
<td align="right">4.22e-05</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree nearest 100 linear</td>
<td align="right">1.57e-04</td>
<td align="right">3.7</td>
</tr>
<tr class="odd">
<td align="left">rtree nearest 100 quadratic</td>
<td align="right">6.68e-05</td>
<td align="right">1.6</td>
</tr>
</tbody>
</table>
<p>As before, the results show kdtools to be as fast or faster than Boost Geometry search. This is not surprising as the R-Tree data structure is optimized for indexing boxed regions, not points. The main conclusion here is that the current implementation of kdtools is reasonably efficient.</p>
</div>
</div>
<div id="mixed-type-searches" class="section level3">
<h3 class="hasAnchor">
<a href="#mixed-type-searches" class="anchor"></a>Mixed-type searches</h3>
<p>Notice that the only requirement of the algorithms is that the <code>get&lt;I&gt;</code> function return a type meeting the <a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">EqualityComparable</a> and <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a> C++ concepts. This means that different dimensions can contain different data types, including strings, for example. The current implementation uses <code>std::get</code> and so is restricted to <code>std::pair</code>, <code>std::tuple</code> and <code>std::array</code>, unless one chooses to specializes in the <code>std</code> namespace, which is generally not recommended. A suitable mechanism for providing type-specific specializations is to-be-implemented. The following example demonstrates sorting and searching a container holding keys of type <code>std::tuple&lt;double, std::string&gt;</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">// [[Rcpp::depends(kdtools)]]</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">// [[Rcpp::plugins(cpp11)]]</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="pp">#include </span><span class="im">"mixed_query.h"</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="dt">void</span> mixed_query(NumericVector c1, CharacterVector c2)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">auto</span> n = c1.size();</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  <span class="dt">range_type</span> data;</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  data.reserve(n);</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  transform(begin(c1), end(c1), begin(c2), back_inserter(data), make_key());</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  <span class="kw">auto</span> t = time_it([&amp;]{</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    kd_sort(begin(data), end(data));</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    </a>
<a class="sourceLine" id="cb9-20" data-line-number="20">  });</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Sort time: "</span> &lt;&lt; t.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb9-23" data-line-number="23">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last "</span> &lt;&lt; N &lt;&lt; <span class="st">" elements of sorted data:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-24" data-line-number="24">  print_range(data);</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">  </a>
<a class="sourceLine" id="cb9-26" data-line-number="26">  <span class="dt">range_type</span> result;</a>
<a class="sourceLine" id="cb9-27" data-line-number="27">  </a>
<a class="sourceLine" id="cb9-28" data-line-number="28">  <span class="kw">auto</span> u = time_it([&amp;]{</a>
<a class="sourceLine" id="cb9-29" data-line-number="29">    </a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    kd_range_query(begin(data), end(data),</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">                   <span class="dt">key_type</span>(<span class="fl">0.4</span>, <span class="st">"w"</span>), <span class="dt">key_type</span>(<span class="fl">0.6</span>, <span class="st">"z"</span>),</a>
<a class="sourceLine" id="cb9-32" data-line-number="32">                   back_inserter(result));</a>
<a class="sourceLine" id="cb9-33" data-line-number="33">    </a>
<a class="sourceLine" id="cb9-34" data-line-number="34">  });</a>
<a class="sourceLine" id="cb9-35" data-line-number="35">  </a>
<a class="sourceLine" id="cb9-36" data-line-number="36">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Query time: "</span> &lt;&lt; u.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-37" data-line-number="37"></a>
<a class="sourceLine" id="cb9-38" data-line-number="38">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last "</span> &lt;&lt; N &lt;&lt; <span class="st">" elements of query return:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-39" data-line-number="39">  kd_sort(begin(result), end(result)); print_range(result);</a>
<a class="sourceLine" id="cb9-40" data-line-number="40">  </a>
<a class="sourceLine" id="cb9-41" data-line-number="41">  result.clear();</a>
<a class="sourceLine" id="cb9-42" data-line-number="42">  </a>
<a class="sourceLine" id="cb9-43" data-line-number="43">  <span class="kw">auto</span> v = time_it([&amp;]{</a>
<a class="sourceLine" id="cb9-44" data-line-number="44">    </a>
<a class="sourceLine" id="cb9-45" data-line-number="45">    kd_nearest_neighbors(begin(data), end(data),</a>
<a class="sourceLine" id="cb9-46" data-line-number="46">                         <span class="dt">key_type</span>(<span class="fl">0.5</span>, <span class="st">"kdtools"</span>), <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb9-47" data-line-number="47">                         back_inserter(result));</a>
<a class="sourceLine" id="cb9-48" data-line-number="48">    </a>
<a class="sourceLine" id="cb9-49" data-line-number="49">  });</a>
<a class="sourceLine" id="cb9-50" data-line-number="50">  </a>
<a class="sourceLine" id="cb9-51" data-line-number="51">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Neighbors query time: "</span> &lt;&lt; v.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-52" data-line-number="52"></a>
<a class="sourceLine" id="cb9-53" data-line-number="53">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last "</span> &lt;&lt; N &lt;&lt; <span class="st">" elements of neighbors query return:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-54" data-line-number="54">  print_range(result);</a>
<a class="sourceLine" id="cb9-55" data-line-number="55">}</a></code></pre></div>
<p>First the data are sorted and then a range query is conducted. The range query selects tuples where the first element ranges from <code>0.4</code> to <code>0.6</code> and the second element begins with letters <code>w</code> through <code>y</code>. For the test, we borrow the words from the <code>parts_of_speech</code> dataset from the <code>tidytext</code> package. It contains more than <span class="math inline">\(10^5\)</span> words.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw"><a href="https://www.rdocumentation.org/packages/utils/topics/data">data</a></span>(<span class="st">"parts_of_speech"</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">numbers =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Round">signif</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Uniform">runif</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/nrow">nrow</a></span>(parts_of_speech)), <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">strings =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/sample">sample</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/chartr">tolower</a></span>(parts_of_speech[[<span class="dv">1</span>]]))</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">mixed_query</span>(numbers, strings)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co">#&gt; Sort time: 0.139143 seconds</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">#&gt; First and last 3 elements of sorted data:</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">#&gt; 0 0.001185 aaronitic</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">#&gt; 1 0.001339 abraded</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="co">#&gt; 2 0.003488 abhorrer</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">#&gt; 208256 0.9989 yeti</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">#&gt; 208257 0.9989 zipangu</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="co">#&gt; 208258 0.999 zapata</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="co">#&gt; Query time: 0.000109588 seconds</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="co">#&gt; First and last 3 elements of query return:</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="co">#&gt; 0 0.4014 wabbled</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23"><span class="co">#&gt; 1 0.4001 wage</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24"><span class="co">#&gt; 2 0.4036 wale</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26"><span class="co">#&gt; 1136 0.5905 yellowbelly</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27"><span class="co">#&gt; 1137 0.5907 yeaton</span></a>
<a class="sourceLine" id="cb10-28" data-line-number="28"><span class="co">#&gt; 1138 0.5976 you'll</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30"><span class="co">#&gt; Neighbors query time: 0.00101591 seconds</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"><span class="co">#&gt; First and last 3 elements of neighbors query return:</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-34" data-line-number="34"><span class="co">#&gt; 0 0.5298 kalis</span></a>
<a class="sourceLine" id="cb10-35" data-line-number="35"><span class="co">#&gt; 1 0.2992 isotopic</span></a>
<a class="sourceLine" id="cb10-36" data-line-number="36"><span class="co">#&gt; 2 0.5283 landsturm</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38"><span class="co">#&gt; 97 0.5092 knowlton</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39"><span class="co">#&gt; 98 0.5253 katholikos</span></a>
<a class="sourceLine" id="cb10-40" data-line-number="40"><span class="co">#&gt; 99 0.4533 jostled</span></a></code></pre></div>
<p>The timing results indicate that sorting <span class="math inline">\(2 \times 10 ^ 5\)</span> tuples is on the order of 1/10th second, whereas the range query returned in less than a millisecond.</p>
<p>Nearest neighbor searching requires a suitable distance function be defined for all types. There are two specialization points: the templates <code>scalar_diff</code>, which returns a possibly signed difference between to objects, and <code>scalar_dist</code>, which returns the distance along a single dimension. Currently, nearest neighbor distances are hardwired as the L2 norm of the returned scalar differences computed for each dimension. The computation above uses the following definitions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span> InputIt1, <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span> InputIt2&gt;</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="dt">double</span> set_similarity(InputIt1 first1, InputIt1 last1,</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">                      InputIt2 first2, InputIt2 last2)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="dt">double</span> num = <span class="dv">0</span>, denom = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="cf">while</span> (first1 != last1 &amp;&amp; first2 != last2) {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="cf">if</span> (*first1 &lt; *first2) {</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">      ++first1; ++denom;</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">      <span class="cf">if</span> (!(*first2 &lt; *first1)) {</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        ++first1; ++num;</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">      }</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">      ++first2; ++denom;</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  denom += <span class="bu">std::</span>distance(first1, last1) + <span class="bu">std::</span>distance(first2, last2);</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">  <span class="cf">return</span> num / denom;</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"></a>
<a class="sourceLine" id="cb11-20" data-line-number="20"><span class="kw">namespace</span> kdtools {</a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="kw">template</span> &lt;&gt;</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"><span class="dt">double</span> scalar_diff(<span class="at">const</span> <span class="bu">std::</span>string&amp; lhs, <span class="at">const</span> <span class="bu">std::</span>string&amp; rhs)</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">{</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">  <span class="bu">std::</span>string a(lhs), b(rhs);</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">  <span class="bu">std::</span>sort(begin(a), end(a));</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">  <span class="bu">std::</span>sort(begin(b), end(b));</a>
<a class="sourceLine" id="cb11-28" data-line-number="28">  <span class="cf">return</span> <span class="dv">1</span> - set_similarity(begin(a), end(a),</a>
<a class="sourceLine" id="cb11-29" data-line-number="29">                            begin(b), end(b));</a>
<a class="sourceLine" id="cb11-30" data-line-number="30">}</a>
<a class="sourceLine" id="cb11-31" data-line-number="31"></a>
<a class="sourceLine" id="cb11-32" data-line-number="32">} <span class="co">// namespace kdtools</span></a></code></pre></div>
<p>The <code>set_similarity</code> template is adapted from the STL <code>set_intersection</code> template and produces a number between 0 and 1. I have not attempted to prove this distance is metric, so the results may not be entirely correct. Also, there is no facility currently available to weight distances in different dimensions or override the default root-sum-of-squares algorithm for the multivariate distance.</p>
<!--

### Indexing with pointer arrays

Since version 0.4.0, ```kd_tools``` all predicates and distance functions have specializations or overloads to handle pointers to tuple-like objects. Hence, any of the routines can sort or search a vector of pointers to tuples, which act as indices into the original data.


```cpp
// [[Rcpp::depends(kdtools)]]
// [[Rcpp::plugins(cpp11)]]

#include "mixed_query.h"

// [[Rcpp::export]]
void sort_pointers(NumericVector c1, CharacterVector c2)
{
  auto n = c1.size();
  
  range_type data;
  data.reserve(n);
  
  transform(begin(c1), end(c1), begin(c2), back_inserter(data), make_key());
  
  pointers_type idx1, idx2;
  idx1.reserve(n); idx2.reserve(n);
  
  for (auto& x : data) {
    idx1.push_back(&x);
    idx2.push_back(&x);
  }
  
  kd_sort(begin(idx1), end(idx1));
  kd_sort(begin(idx2), end(idx2), greater_key());

  Rcout << "Original order\n\n"; print_range(data);
  Rcout << "\nOrder by less\n\n"; print_range(idx1);
  Rcout << "\nOrder by greater\n\n"; print_range(idx2);
}
```

Here, ```greater_key``` has overloads for both string and double types.


```r
#sort_pointers(numbers, strings)
```

Note that the forward and reverse sorting do not give exactly the same result (in reverse) owing to ties.

-->
</div>
</div>
<div id="conclusions" class="section level2">
<h2 class="hasAnchor">
<a href="#conclusions" class="anchor"></a>Conclusions</h2>
<p>The kdtools package implements efficient sorting and searching of arbitary tuple-like object in C++. One of the major design decisions was to make the number of dimensions fixed at compile time. This is a reasonable tradeoff as these methods break down in high dimensions where search times will be no better than that of brute-force random searching. Nonetheless, a runtime-dimensioned extension would be easy to add and could allow working with runtime-determined types as is common in R. The current implementation is a demonstration, however it does illustrate the value of the STL as the algorithms are constructed from STL components. The generic nature of the kdtools implementation is an attractive feature as it permits flexibility and can be adapted to arbitrary tuple-like data as needed. Modern development of C++ has emphasized tuple-style data and algorithms and kdtools extends these developments.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#sorting">Sorting</a></li>
      <li><a href="#conclusions">Conclusions</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Timothy Keitt.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
