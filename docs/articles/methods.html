<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Compact multidimensional sorting and searching with kdtools â€¢ kdtools</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Compact multidimensional sorting and searching with kdtools">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">kdtools</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.4.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/kdtools.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/methods.html">Compact multidimensional sorting and searching with kdtools</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/thk686/kdtools">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Compact multidimensional sorting and searching with kdtools</h1>
                        <h4 class="author">Timothy H. Keitt</h4>
            
            <h4 class="date">2020-01-08</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/thk686/kdtools/blob/master/vignettes/methods.Rmd"><code>vignettes/methods.Rmd</code></a></small>
      <div class="hidden name"><code>methods.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>Sorting and searching are fundamental operations in computer and data science. The objective of the <code>kdtools</code> is to expose a C++ header file implementing efficient sorting and searching methods for multidimensional tuple-like data. The interface mirrors that of the <a href="http://en.cppreference.com/w/">C++ Standard Library</a> sorting and searching functions. It is a single header-only library with no external dependencies other than <code>std</code>.</p>
<p>A common approach to improving search performance is to place data into an ordered tree structure, the most common being a binary tree and its variants. Computer textbooks and introductory courses are littered with examples of tree structures, however it <a href="http://scottmeyers.blogspot.com/2015/09/should-you-be-using-something-instead.html">has been pointed out by practitioners</a> that many tree-type data structures have considerable storage overhead and poor memory locality. This results from using linked-list-like pointers to connect nodes. In many cases, a fully or partially sorted sequence combined with binary search will outperform pointer-based trees. Indeed, <a href="http://en.cppreference.com/w/cpp/algorithm">the Standard Library contains a set of algorithms</a> for sorting or partitioning a data sequence and searching within partitioned sequences.</p>
<p>A limitation of the Standard Library algorithms and data structures is that they can only be ordered in a single dimension. Sort keys can possess higher cardinality however comparison operators and ordering are unidimensional. This is suboptimal for data that are intrinsically multidimensional, such as geographical coordinates or other multivariate data. In multiple dimensions, it is preferred to order a sequence of keys such the average distance between neighboring pairs in the sequence is small. There exist a vast array of techniques to accomplish sequence localization; however I will only discuss one known as the <a href="https://en.wikipedia.org/wiki/K-d_tree">kd-tree</a>.</p>
<p>A kd-tree is a type of binary tree that cycles among the dimensions of its stored objects at each level of the tree hierarchy. In the case of spatial data, the root node will contain the median key in the x-direction and each of its daughter nodes will contain the median in the y-direction of their respective partitions. Subsequent daughter nodes will again contain medians in the x-direction, and so on until there are no additional keys to the left or right. Searching a kd-tree involves recursive comparisons, cycling among the dimensions, until a leaf-node is encountered. Most searching operations can be accomplished in logarithmic time complexity yielding an efficient method.</p>
<p>Precisely as an ordinary binary tree can be replaced by a sorted range, a sequence of multidimensional elements can be sorted, in-place if desired, via recursive partitioning following the kd-tree scheme. Divide-and-conquer recursive partitioning is a well-known sorting algorithm and is the basis of the <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort algorithm</a>. Partitioning a sequence places all elements less than (or more generally meeting some predicate) to the left of a selected key, while all elements greater-than-or-equal-to follow to the right. The kd-sort algorithm presented here simply modifies quicksort to cycle among the dimensions of the stored elements. Searching follows exactly as the kd-tree except that nodes correspond to pivot-elements in the linear array.</p>
<p>Implementation of <code>kd_sort</code> enables a set of additional algorithms for searching and nearest neighbor queries. The following table gives the exposed functions and corresponding Standard Library routines.</p>
<table class="table">
<colgroup>
<col width="25%">
<col width="20%">
<col width="53%">
</colgroup>
<thead><tr class="header">
<th>Function templates</th>
<th>SL analog</th>
<th>Outcome</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>kd_sort</td>
<td>sort</td>
<td>sorts range</td>
</tr>
<tr class="even">
<td>kd_is_sorted</td>
<td>is_sorted</td>
<td>returns <code>true</code> if sorted</td>
</tr>
<tr class="odd">
<td>kd_lower_bound</td>
<td>lower_bound</td>
<td>finds first element not less than key for all dimensions</td>
</tr>
<tr class="even">
<td>kd_upper_bound</td>
<td>upper_bound</td>
<td>finds first element greater than key for all dimensions</td>
</tr>
<tr class="odd">
<td>kd_binary_search</td>
<td>binary_search</td>
<td>returns true if key exists in range</td>
</tr>
<tr class="even">
<td>kd_equal_range</td>
<td>equal_range</td>
<td>returns an iterator pair spanning all occurrences of a key</td>
</tr>
<tr class="odd">
<td>kd_range_query</td>
<td>lower_bound, upper_bound</td>
<td>finds all elements not less than lower and less than upper</td>
</tr>
<tr class="even">
<td>kd_nearest_neighbor</td>
<td></td>
<td>finds nearest neighbor of key</td>
</tr>
<tr class="odd">
<td>kd_nearest_neighbors, kd_nn_indices</td>
<td></td>
<td>finds k-nearest neighbors of key</td>
</tr>
<tr class="even">
<td>lex_sort</td>
<td></td>
<td>ordinary SL sort using kd_less for comparison</td>
</tr>
</tbody>
</table>
</div>
<div id="sorting" class="section level2">
<h2 class="hasAnchor">
<a href="#sorting" class="anchor"></a>Sorting</h2>
<p>The kd-sort algorithm in the kdtools package is implemented as a C++ function template parameterized by the starting dimension (usually 0) and the iterator type, which will be auto-deduced by the compiler.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="kw">typename</span> Iter&gt;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dt">void</span> kd_sort(Iter first, Iter last)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">using</span> TupleType = <span class="dt">iter_value_t</span>&lt;Iter&gt;;</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="cf">if</span> (distance(first, last) &gt; <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  {</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="kw">auto</span> pred = kd_less&lt;I&gt;();</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="kw">auto</span> pivot = median_part(first, last, pred);</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    kd_sort&lt;J&gt;(next(pivot), last);</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    kd_sort&lt;J&gt;(first, pivot);</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">}</a></code></pre></div>
<p>The <code>median_part</code> function is a thin wrapper around the <a href="http://en.cppreference.com/w/cpp/algorithm/nth_element"><code>nth_element</code></a> function from the standard library, which is used to find the median value in the current dimension. Elements to the left of the nth element are not greater than the nth element and elements to the right are not less than the nth element. This allows searching left or right depending on whether the sought value is not greater than the median or not less than the median (ties must search both directions).</p>
<p>Once the first dimension is partitioned, the ranges right and left of the pivot are partitioned, and so on until first and last span a single or no value. The dimension index <code>I</code> is incremented at compile-time using template metaprogramming. The <code>value</code> member of the templated struct <code>next_dim</code> holds the incremented value of <code>I</code> that has been wrapped to cycle through successive dimensions of <code>TupleType</code>. The result of <code>kd_sort</code> is a sequence ordered as if it were inserted into a kd-tree data structure. The following figure illustrates the resulting order in 2-dimensions.</p>
<p><img src="methods_files/figure-html/unnamed-chunk-2-1.png" width="576"></p>
<p>Here the sequence order is shown with a continuous color gradient. The resulting patchiness indicates a hierarchical tree-like partitioning of the space providing the desired locality. Placing nearby points in proximity is what allows for efficient searches once the data are sorted. Sort times for vectors of tuple-like objects are relatively efficient, taking roughly twice the time of an ordinary lexicographical sort.</p>
<p><img src="methods_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>In the above results, <code>lex_sort</code> is the Standard Library built-in <a href="http://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a> algorithm using <code>kd_less</code> as the predicate. The results indicate that <code>kd_sort</code> is reasonably fast, requiring roughly twice the time as the Standard Library built-in sorting algorithm. Because of the divide-and-conquer nature of <code>kd_sort</code>, it is trivially parallelizable. The threaded version is equal to or faster than the regular sort. Performance comparable to the build-in Standard Library <code>sort</code> function indicates that this reference implementation is reasonable.</p>
<div id="multidimensional-comparisons" class="section level3">
<h3 class="hasAnchor">
<a href="#multidimensional-comparisons" class="anchor"></a>Multidimensional comparisons</h3>
<p>To ensure the correct behavior in the presence of multiple ties, or even when all keys in one dimension are equal, the <code>kd_less</code> predicate implements circular lexicographic comparison. If elements in one dimension are tied, the next dimension is interrogated to break the tie. The comparisons cycle from trailing dimensions to leading dimensions using modulo arithmetic. It is implemented as a recursive, templated function object with the dimension index incremented at compile-time. The recursion is terminated using <a href="https://en.cppreference.com/w/cpp/language/if">constexpr if</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="dt">size_t</span> K = <span class="dv">0</span>&gt;</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">struct</span> kd_less</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="dt">bool</span> <span class="kw">operator</span>()(<span class="at">const</span> T&amp; lhs, <span class="at">const</span> T&amp; rhs) <span class="at">const</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  {</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    <span class="cf">if</span> <span class="kw">constexpr</span> (is_last&lt;K, T&gt;) {</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="cf">return</span> less_nth&lt;I&gt;()(lhs, rhs);</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, T&gt;;</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">      <span class="cf">return</span> equal_nth&lt;I&gt;()(lhs, rhs) ?</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        kd_less&lt;J, K + <span class="dv">1</span>&gt;()(lhs, rhs) :</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">          less_nth&lt;I&gt;()(lhs, rhs);</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">};</a></code></pre></div>
<p>The predicates <code>equal_nth</code> and <code>less_nth</code> compare the <span class="math inline">\(I^{th}\)</span> element of the tuple. They have specializations for handling pointers to tuple-like object, so all functions can operate on a range over pointers to tuples, allowing arbitrary indexing into the original data.</p>
<p>A more general function object template <code>kd_compare</code> that takes an arbitrary binary predicate is also provided by <code>kdtools</code>. Some examples applying <code>kd_less</code>, including degenerate, all-ties cases, are shown here.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">j =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">k =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(j))</a></code></pre></div>
<table class="table"><tbody><tr class="odd">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr></tbody></table>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(j, k)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">7</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">6</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
</tbody></table>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="dv">0</span>, j, k)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="right">7</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">6</td>
</tr>
</tbody></table>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(j, k, <span class="dv">0</span>)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">1</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">7</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">6</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody></table>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw"><a href="https://rdrr.io/r/base/t.html">t</a></span>(<span class="kw"><a href="../reference/kdsort.html">kd_sort</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="dv">0</span>, j, <span class="dv">0</span>)))</a></code></pre></div>
<table class="table"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">4</td>
<td align="right">5</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">8</td>
<td align="right">9</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody></table>
<p>Notice that <code>kd_sort</code> is a variant of the quicksort algorithm in one dimension. It also is not effected by all-ties. The order of subsequent dimensions can be changed when the leading dimension contains all ties, however the sequence is still sorted and can be used for searching.</p>
</div>
<div id="searching" class="section level3">
<h3 class="hasAnchor">
<a href="#searching" class="anchor"></a>Searching</h3>
<p>Once data are ordered appropriately, searching can be achieved efficiently. The <code>kdtools</code> package provides analogs of the Standard Library <a href="http://en.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound</code></a>, <a href="http://en.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound</code></a>, <a href="http://en.cppreference.com/w/cpp/algorithm/equal_range"><code>equal_range</code></a> and <a href="http://en.cppreference.com/w/cpp/algorithm/binary_search"><code>binary_search</code></a> functions for querying sorted ranges. An additional function, <code>kd_range_query</code>, does efficient searching within a boxed region.</p>
<p>The <code>kd_lower_bound</code>, <code>kd_upper_bound</code> and <code>kd_equal_range</code> algorithms behave differently than their unidimensional analogs. This is because the only reasonable definition of multidimensional less is to require less in all dimensions simultaneously. As illustrated below, this leads to cases where some, but not all, elements are less to be included in the interval spanned by <code>kd_lower_bound</code>, <code>kd_upper_bound</code> and <code>kd_equal_range</code>. In other words, in a single dimension, these routines are both necessary and sufficient, whereas in multiple-dimensions, they are necessary, but not sufficient to uniquely identify elements in a boxed region.</p>
<p>In other schemes, such as <a href="https://en.wikipedia.org/wiki/Z-order_curve">Morton codes</a>, elaborate subroutines are required to prune the extra elements falling outside the region of interest (see lower-left panel below). This is a result of using a fundamentally unidimensional search on multidimensional data. Instead <code>kd_sort</code> implements direct binary search for points falling within a boxed region.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I,</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">          <span class="kw">typename</span> Iter,</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="kw">typename</span> TupleType,</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="kw">typename</span> OutIter&gt;</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="dt">void</span> kd_range_query(Iter first, Iter last,</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                    <span class="at">const</span> TupleType&amp; lower,</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                    <span class="at">const</span> TupleType&amp; upper,</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                    OutIter outp)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">{</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="cf">if</span> (distance(first, last) &gt; <span class="dv">32</span>) {</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">auto</span> pred = less_nth&lt;I&gt;();</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    <span class="kw">auto</span> pivot = find_pivot&lt;I&gt;(first, last);</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="kw">constexpr</span> <span class="kw">auto</span> J = next_dim&lt;I, TupleType&gt;;</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    <span class="cf">if</span> (within(*pivot, lower, upper)) *outp++ = *pivot;</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    <span class="cf">if</span> (!pred(*pivot, lower)) <span class="co">// search left</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      kd_range_query&lt;J&gt;(first, pivot, lower, upper, outp);</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="cf">if</span> (pred(*pivot, upper)) <span class="co">// search right</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">      kd_range_query&lt;J&gt;(next(pivot), last, lower, upper, outp);</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    copy_if(first, last, outp, [&amp;](<span class="at">const</span> TupleType&amp; x){</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      <span class="cf">return</span> within(x, lower, upper);</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    });</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">}</a></code></pre></div>
<p>Here, each pivot element is tested to see whether it falls within the boxed region, in which case, it is assigned to the output iterator. The template <code>find_pivot</code> searches for the partition point whose position may or may not be the middle of the sequence. Leaf tuples are also tested and copied to the output iterator. We check in each dimension whether there might be additional points in the region of interest to the left or right in the array. These are searched recursively until reaching the span falls below a threshold and is more profitably searched via sequential scan. In the following plot, the blue points indicate those not meeting the predicate and the aquamarine points are those where the predicate returns true.</p>
<p><img src="methods_files/figure-html/unnamed-chunk-9-1.png" width="480"></p>
</div>
<div id="performance-comparison-to-boost-geometry" class="section level3">
<h3 class="hasAnchor">
<a href="#performance-comparison-to-boost-geometry" class="anchor"></a>Performance comparison to Boost Geometry</h3>
<p>The <a href="http://www.boost.org/doc/libs/release/libs/geometry/">Boost Geometry library</a> is a highly sophisticated and performant framework for working with geometric features. It includes an <a href="https://en.wikipedia.org/wiki/R-tree">R-Tree index</a> that allows access to objects within a bounding region in logarithmic time. Here I compare the speed of building and querying a collection of points. The only purpose of this comparison is to look for large (i.e., 5 to 10 fold) differences, which would indicate a problem in the implementation. Small differences in measured times are probably not meaningful and will likely change on different systems. Reported results are the median of 21 trials using 10^{7} tuples.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_sort_threaded</td>
<td align="right">0.471</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">kd_sort inplace</td>
<td align="right">2.970</td>
<td align="right">6.3</td>
</tr>
<tr class="odd">
<td align="left">kd_sort w/ copy</td>
<td align="right">3.090</td>
<td align="right">6.6</td>
</tr>
<tr class="even">
<td align="left">rtree pack linear</td>
<td align="right">3.700</td>
<td align="right">7.9</td>
</tr>
<tr class="odd">
<td align="left">rtree pack quadratic</td>
<td align="right">3.710</td>
<td align="right">7.9</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_range_query</td>
<td align="right">0.000857</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree query linear</td>
<td align="right">0.003380</td>
<td align="right">3.9</td>
</tr>
<tr class="odd">
<td align="left">rtree query quadratic</td>
<td align="right">0.003160</td>
<td align="right">3.7</td>
</tr>
</tbody>
</table>
<p>The results indicate that sorting and searching with kdtools is at least as performant as using Boost Geometry. Generally, an R-Tree will have an advantage with many individual insertions and deletions, whereas a sorted range will be more compact and show equal, if not better, query performance.</p>
<div id="nearest-neighbor-search" class="section level4">
<h4 class="hasAnchor">
<a href="#nearest-neighbor-search" class="anchor"></a>Nearest-neighbor search</h4>
<p>The kdtools package also provides routines for nearest- and k-nearest- neighbor search.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_nearest_neighbor</td>
<td align="right">6.00e-06</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree nearest neighbor linear</td>
<td align="right">5.50e-05</td>
<td align="right">9.1</td>
</tr>
<tr class="odd">
<td align="left">rtree nearest neighbor quadratic</td>
<td align="right">1.55e-05</td>
<td align="right">2.6</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th align="left">Test</th>
<th align="right">Time</th>
<th align="right">Ratio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">kd_nearest_neighbors 100</td>
<td align="right">3.87e-05</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">rtree nearest 100 linear</td>
<td align="right">1.50e-04</td>
<td align="right">3.9</td>
</tr>
<tr class="odd">
<td align="left">rtree nearest 100 quadratic</td>
<td align="right">7.40e-05</td>
<td align="right">1.9</td>
</tr>
</tbody>
</table>
<p>As before, the results show kdtools to be as fast or faster than Boost Geometry search. This is not surprising as the R-Tree data structure is optimized for indexing boxed regions, not points. The main conclusion here is that the current implementation of kdtools is reasonably efficient.</p>
</div>
</div>
<div id="mixed-type-searches" class="section level3">
<h3 class="hasAnchor">
<a href="#mixed-type-searches" class="anchor"></a>Mixed-type searches</h3>
<p>Notice that the only requirement of the algorithms is that the <code>get&lt;I&gt;</code> function return a type meeting the <a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">EqualityComparable</a> and <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a> C++ concepts. This means that different dimensions can contain different data types, including strings, for example. The current implementation uses <code>std::get</code> and so is restricted to <code>std::pair</code>, <code>std::tuple</code> and <code>std::array</code>, unless one chooses to specializes in the <code>std</code> namespace, which is generally not recommended. A suitable mechanism for providing type-specific specializations is to-be-implemented. The following example demonstrates sorting and searching a container holding keys of type <code>std::tuple&lt;double, std::string&gt;</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">// [[Rcpp::depends(kdtools)]]</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">// [[Rcpp::plugins(cpp17)]]</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="pp">#include </span><span class="im">"mixed_query.h"</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="dt">void</span> mixed_query(NumericVector c1, CharacterVector c2)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">auto</span> n = c1.size();</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  <span class="dt">range_type</span> data;</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  data.reserve(n);</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  transform(begin(c1), end(c1), begin(c2), back_inserter(data), make_key());</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  <span class="kw">auto</span> t = time_it([&amp;]{</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    kd_sort(begin(data), end(data));</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    </a>
<a class="sourceLine" id="cb9-20" data-line-number="20">  });</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Sort time: "</span> &lt;&lt; t.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb9-23" data-line-number="23">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last "</span> &lt;&lt; N &lt;&lt; <span class="st">" elements of sorted data:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-24" data-line-number="24">  print_range(data);</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">  </a>
<a class="sourceLine" id="cb9-26" data-line-number="26">  <span class="dt">range_type</span> result;</a>
<a class="sourceLine" id="cb9-27" data-line-number="27">  </a>
<a class="sourceLine" id="cb9-28" data-line-number="28">  <span class="kw">auto</span> u = time_it([&amp;]{</a>
<a class="sourceLine" id="cb9-29" data-line-number="29">    </a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    kd_range_query(begin(data), end(data),</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">                   <span class="dt">key_type</span>(<span class="fl">0.4</span>, <span class="st">"w"</span>), <span class="dt">key_type</span>(<span class="fl">0.6</span>, <span class="st">"z"</span>),</a>
<a class="sourceLine" id="cb9-32" data-line-number="32">                   back_inserter(result));</a>
<a class="sourceLine" id="cb9-33" data-line-number="33">    </a>
<a class="sourceLine" id="cb9-34" data-line-number="34">  });</a>
<a class="sourceLine" id="cb9-35" data-line-number="35">  </a>
<a class="sourceLine" id="cb9-36" data-line-number="36">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Query time: "</span> &lt;&lt; u.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-37" data-line-number="37"></a>
<a class="sourceLine" id="cb9-38" data-line-number="38">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last "</span> &lt;&lt; N &lt;&lt; <span class="st">" elements of query return:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-39" data-line-number="39">  kd_sort(begin(result), end(result)); print_range(result);</a>
<a class="sourceLine" id="cb9-40" data-line-number="40">  </a>
<a class="sourceLine" id="cb9-41" data-line-number="41">  result.clear();</a>
<a class="sourceLine" id="cb9-42" data-line-number="42">  </a>
<a class="sourceLine" id="cb9-43" data-line-number="43">  <span class="kw">auto</span> v = time_it([&amp;]{</a>
<a class="sourceLine" id="cb9-44" data-line-number="44">    </a>
<a class="sourceLine" id="cb9-45" data-line-number="45">    kd_nearest_neighbors(begin(data), end(data),</a>
<a class="sourceLine" id="cb9-46" data-line-number="46">                         <span class="dt">key_type</span>(<span class="fl">0.5</span>, <span class="st">"kdtools"</span>), <span class="dv">100</span>,</a>
<a class="sourceLine" id="cb9-47" data-line-number="47">                         back_inserter(result));</a>
<a class="sourceLine" id="cb9-48" data-line-number="48">    </a>
<a class="sourceLine" id="cb9-49" data-line-number="49">  });</a>
<a class="sourceLine" id="cb9-50" data-line-number="50">  </a>
<a class="sourceLine" id="cb9-51" data-line-number="51">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Neighbors query time: "</span> &lt;&lt; v.count() &lt;&lt; <span class="st">" seconds"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-52" data-line-number="52"></a>
<a class="sourceLine" id="cb9-53" data-line-number="53">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">First and last "</span> &lt;&lt; N &lt;&lt; <span class="st">" elements of neighbors query return:</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb9-54" data-line-number="54">  print_range(result);</a>
<a class="sourceLine" id="cb9-55" data-line-number="55">}</a></code></pre></div>
<p>First the data are sorted and then a range query is conducted. The range query selects tuples where the first element ranges from <code>0.4</code> to <code>0.6</code> and the second element begins with letters <code>w</code> through <code>y</code>. For the test, we borrow the words from the <code>parts_of_speech</code> dataset from the <code>tidytext</code> package. It contains more than <span class="math inline">\(10^5\)</span> words.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(<span class="st">"parts_of_speech"</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">numbers =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Round.html">signif</a></span>(<span class="kw"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span>(parts_of_speech)), <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">strings =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/sample.html">sample</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/chartr.html">tolower</a></span>(parts_of_speech[[<span class="dv">1</span>]]))</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">mixed_query</span>(numbers, strings)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co">#&gt; Sort time: 0.113314 seconds</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">#&gt; First and last 3 elements of sorted data:</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">#&gt; 0 0.003233 abominably</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">#&gt; 1 0.00444 acalia</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="co">#&gt; 2 0.004726 acenesthesia</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">#&gt; 208256 0.9976 zap</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">#&gt; 208257 0.9975 ziusudra</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="co">#&gt; 208258 0.9995 zinfandel</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="co">#&gt; Query time: 0.000114316 seconds</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="co">#&gt; First and last 3 elements of query return:</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="co">#&gt; 0 0.4109 wackily</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23"><span class="co">#&gt; 1 0.4079 waechter</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24"><span class="co">#&gt; 2 0.4151 waggon</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26"><span class="co">#&gt; 1077 0.5864 yttric</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27"><span class="co">#&gt; 1078 0.5894 yumuk</span></a>
<a class="sourceLine" id="cb10-28" data-line-number="28"><span class="co">#&gt; 1079 0.5954 ytterbite</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30"><span class="co">#&gt; Neighbors query time: 0.000894374 seconds</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"><span class="co">#&gt; First and last 3 elements of neighbors query return:</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb10-34" data-line-number="34"><span class="co">#&gt; 0 0.2797 joktaleg</span></a>
<a class="sourceLine" id="cb10-35" data-line-number="35"><span class="co">#&gt; 1 0.5602 kelsi</span></a>
<a class="sourceLine" id="cb10-36" data-line-number="36"><span class="co">#&gt; 2 0.7966 khlysty</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38"><span class="co">#&gt; 97 0.5269 lobos</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39"><span class="co">#&gt; 98 0.3426 kelotomies</span></a>
<a class="sourceLine" id="cb10-40" data-line-number="40"><span class="co">#&gt; 99 0.5357 kolos</span></a></code></pre></div>
<p>The timing results indicate that sorting <span class="math inline">\(2 \times 10 ^ 5\)</span> tuples is on the order of 1/10th second, whereas the range query returned in less than a millisecond.</p>
<p>Nearest neighbor searching requires a suitable distance function be defined for all types. There are two specialization points: the templates <code>scalar_diff</code>, which returns a possibly signed difference between to objects, and <code>scalar_dist</code>, which returns the distance along a single dimension. Currently, nearest neighbor distances are hardwired as the L2 norm of the returned scalar differences computed for each dimension. The computation above uses the following definitions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw"><a href="https://rdrr.io/r/base/class.html">class</a></span> InputIt1, <span class="kw"><a href="https://rdrr.io/r/base/class.html">class</a></span> InputIt2&gt;</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="dt">double</span> set_similarity(InputIt1 first1, InputIt1 last1,</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">                      InputIt2 first2, InputIt2 last2)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">{</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="dt">double</span> num = <span class="dv">0</span>, denom = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="cf">while</span> (first1 != last1 &amp;&amp; first2 != last2) {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="cf">if</span> (*first1 &lt; *first2) {</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">      ++first1; ++denom;</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">      <span class="cf">if</span> (!(*first2 &lt; *first1)) {</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        ++first1; ++num;</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">      }</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">      ++first2; ++denom;</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  denom += <span class="bu">std::</span>distance(first1, last1) + <span class="bu">std::</span>distance(first2, last2);</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">  <span class="cf">return</span> num / denom;</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"></a>
<a class="sourceLine" id="cb11-20" data-line-number="20"><span class="kw">namespace</span> kdtools {</a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="kw">template</span> &lt;&gt;</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"><span class="dt">double</span> scalar_diff(<span class="at">const</span> <span class="bu">std::</span>string&amp; lhs, <span class="at">const</span> <span class="bu">std::</span>string&amp; rhs)</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">{</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">  <span class="bu">std::</span>string a(lhs), b(rhs);</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">  <span class="bu">std::</span>sort(begin(a), end(a));</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">  <span class="bu">std::</span>sort(begin(b), end(b));</a>
<a class="sourceLine" id="cb11-28" data-line-number="28">  <span class="cf">return</span> <span class="dv">1</span> - set_similarity(begin(a), end(a),</a>
<a class="sourceLine" id="cb11-29" data-line-number="29">                            begin(b), end(b));</a>
<a class="sourceLine" id="cb11-30" data-line-number="30">}</a>
<a class="sourceLine" id="cb11-31" data-line-number="31"></a>
<a class="sourceLine" id="cb11-32" data-line-number="32">} <span class="co">// namespace kdtools</span></a></code></pre></div>
<p>The <code>set_similarity</code> template is adapted from the Standard Library <code>set_intersection</code> template and produces a number between 0 and 1. I have not attempted to prove this distance is metric, so the results may not be entirely correct. Also, there is no facility currently available to weight distances in different dimensions or override the default root-sum-of-squares algorithm for the multivariate distance.</p>
</div>
<div id="indexing-with-pointer-arrays" class="section level3">
<h3 class="hasAnchor">
<a href="#indexing-with-pointer-arrays" class="anchor"></a>Indexing with pointer arrays</h3>
<p>Since version 0.4.0, <code>kd_tools</code> all predicates and distance functions have specializations or overloads to handle pointers to tuple-like objects. Hence, any of the routines can sort or search a vector of pointers to tuples, which act as indices into the original data.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">// [[Rcpp::depends(kdtools)]]</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">// [[Rcpp::plugins(cpp17)]]</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="pp">#include </span><span class="im">"mixed_query.h"</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="dt">void</span> sort_pointers(NumericVector c1, CharacterVector c2)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  <span class="kw">auto</span> n = c1.size();</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="dt">range_type</span> data;</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">  data.reserve(n);</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb12-14" data-line-number="14">  transform(begin(c1), end(c1), begin(c2), back_inserter(data), make_key());</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb12-16" data-line-number="16">  <span class="dt">pointers_type</span> idx1, idx2;</a>
<a class="sourceLine" id="cb12-17" data-line-number="17">  idx1.reserve(n); idx2.reserve(n);</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">  </a>
<a class="sourceLine" id="cb12-19" data-line-number="19">  <span class="cf">for</span> (<span class="kw">auto</span>&amp; x : data) {</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">    idx1.push_back(&amp;x);</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">    idx2.push_back(&amp;x);</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">  }</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">  </a>
<a class="sourceLine" id="cb12-24" data-line-number="24">  kd_sort(begin(idx1), end(idx1));</a>
<a class="sourceLine" id="cb12-25" data-line-number="25">  kd_sort(begin(idx2), end(idx2), greater_key());</a>
<a class="sourceLine" id="cb12-26" data-line-number="26"></a>
<a class="sourceLine" id="cb12-27" data-line-number="27">  Rcout &lt;&lt; <span class="st">"Original order</span><span class="sc">\n\n</span><span class="st">"</span>; print_range(data);</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Order by less</span><span class="sc">\n\n</span><span class="st">"</span>; print_range(idx1);</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">  Rcout &lt;&lt; <span class="st">"</span><span class="sc">\n</span><span class="st">Order by greater</span><span class="sc">\n\n</span><span class="st">"</span>; print_range(idx2);</a>
<a class="sourceLine" id="cb12-30" data-line-number="30">}</a></code></pre></div>
<p>Here, <code>greater_key</code> has overloads for both string and double types.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">sort_pointers</span>(numbers, strings)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="co">#&gt; Original order</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="co">#&gt; 0 0.6913 bil</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co">#&gt; 1 0.6877 pernephria</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="co">#&gt; 2 0.5762 fanfish</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="co">#&gt; 208256 0.07884 degrade</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="co">#&gt; 208257 0.9035 huascar</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="co">#&gt; 208258 0.726 melicent</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"><span class="co">#&gt; Order by less</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="co">#&gt; 0 0.003233 abominably</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="co">#&gt; 1 0.00444 acalia</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="co">#&gt; 2 0.004726 acenesthesia</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18"><span class="co">#&gt; 208256 0.9976 zap</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="co">#&gt; 208257 0.9975 ziusudra</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="co">#&gt; 208258 0.9995 zinfandel</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22"><span class="co">#&gt; Order by greater</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"><span class="co">#&gt; 0 0.9995 zinfandel</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25"><span class="co">#&gt; 1 0.9976 zap</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="co">#&gt; 2 0.9975 ziusudra</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"><span class="co">#&gt; ...</span></a>
<a class="sourceLine" id="cb13-28" data-line-number="28"><span class="co">#&gt; 208256 0.004726 acenesthesia</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29"><span class="co">#&gt; 208257 0.00444 acalia</span></a>
<a class="sourceLine" id="cb13-30" data-line-number="30"><span class="co">#&gt; 208258 0.003233 abominably</span></a></code></pre></div>
<p>Note that the forward and reverse sorting do not give exactly the same result (in reverse) owing to ties.</p>
</div>
</div>
<div id="conclusions" class="section level2">
<h2 class="hasAnchor">
<a href="#conclusions" class="anchor"></a>Conclusions</h2>
<p>The kdtools package implements efficient sorting and searching of arbitary tuple-like object in C++. One of the major design decisions was to make the number of dimensions fixed at compile time. This is a reasonable tradeoff as these methods break down in high dimensions where search times will be no better than that of brute-force random searching. Nonetheless, a runtime-dimensioned extension would be easy to add and could allow working with runtime-determined types as is common in R. The current implementation is a demonstration, however it does illustrate the value of the Standard Library as the algorithms are constructed from Standard Library components. The generic nature of the kdtools implementation is an attractive feature as it permits flexibility and can be adapted to arbitrary tuple-like data as needed. Modern development of C++ has emphasized tuple-style data and algorithms and kdtools extends these developments.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#sorting">Sorting</a></li>
      <li><a href="#conclusions">Conclusions</a></li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Timothy Keitt.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
