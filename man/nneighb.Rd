% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kdtools.R
\name{kd_nearest_neighbors}
\alias{kd_nearest_neighbors}
\alias{kd_nearest_neighbors.arrayvec}
\alias{kd_nearest_neighbors.matrix}
\alias{kd_nearest_neighbors.data.frame}
\alias{kd_nn_indices}
\alias{kd_nn_indices.arrayvec}
\alias{kd_nn_indices.matrix}
\alias{kd_nn_indices.data.frame}
\alias{kd_nearest_neighbor}
\alias{kd_nearest_neighbor.arrayvec}
\alias{kd_nearest_neighbor.matrix}
\title{Find nearest neighbors}
\usage{
kd_nearest_neighbors(x, v, n, ...)

\method{kd_nearest_neighbors}{arrayvec}(x, v, n, p = 2, a = 0, ...)

\method{kd_nearest_neighbors}{matrix}(x, v, n, cols = NULL, p = 2, a = 0, ...)

\method{kd_nearest_neighbors}{data.frame}(x, v, n, cols = NULL, w = NULL, p = 2, a = 0, ...)

kd_nn_indices(x, v, n, ...)

\method{kd_nn_indices}{arrayvec}(x, v, n, distances = FALSE, p = 2, a = 0, ...)

\method{kd_nn_indices}{matrix}(
  x,
  v,
  n,
  cols = NULL,
  distances = FALSE,
  p = 2,
  a = 0,
  validate = TRUE,
  ...
)

\method{kd_nn_indices}{data.frame}(
  x,
  v,
  n,
  cols = NULL,
  w = NULL,
  distances = FALSE,
  p = 2,
  a = 0,
  validate = TRUE,
  ...
)

kd_nearest_neighbor(x, v)

\method{kd_nearest_neighbor}{arrayvec}(x, v)

\method{kd_nearest_neighbor}{matrix}(x, v)
}
\arguments{
\item{x}{an object sorted by \code{\link{kd_sort}}}

\item{v}{a vector specifying where to look}

\item{n}{the number of neighbors to return}

\item{...}{ignored}

\item{p}{exponent of p-norm (Minkowski) distance}

\item{a}{approximate neighbors within (1 + a)}

\item{cols}{integer or character vector or formula indicating columns}

\item{w}{distance weights}

\item{distances}{return distances as attribute if true}

\item{validate}{if FALSE, no input validation is performed}
}
\value{
\tabular{ll}{
\code{kd_nearest_neighbors} \tab one or more rows from the sorted input \cr
\code{kd_nn_indices} \tab a vector of row indices indicating the result \cr
\code{kd_nearest_neighbor} \tab the row index of the neighbor \cr
}
}
\description{
Find nearest neighbors
}
\details{
Distance is calculated as
\deqn{D_{ij} = [\sum_k w_k G(x_{ik}, x_{jk}) ^ p] ^ {1 / p}}
where \eqn{i} and \eqn{j} are records, \eqn{k} is the \eqn{k}th field or
tuple element, and \eqn{w_k} is the weight in the \eqn{k}th dimension. Here,
\eqn{G} depends on the type. For reals, \eqn{G(a, b) = |a - b|}.
For logicals and integers, \eqn{G(a, b)} is one if \eqn{a = b}
and zero otherwise. For strings, \eqn{G(a, b)} is Levenshtein or edit distance.
Convert strings to factors unless edit distance makes sense for your application.

When using the \code{cols} argument, the search key \code{v} is handled specially. If
the length of \code{v} is equal to the number of columns of \code{x}, then it is
assumed that the key is given in the same order as the columns of \code{x}. In that case,
the key \code{v} is mapped through the \code{cols} argument. This will possibly
change the order of the elements and length of the search key. The reason for this
is that it allows one to use a row of \code{x} as the key and it will respect the
\code{cols} argument. Otherwise, or if \code{validate} is \code{FALSE}, the search
key \code{v} is passed unchanged and must be given with the correct length and order
to match the \code{cols} argument. The same is true of the \code{w} parameter.
}
\examples{
if (has_cxx17()) {
x = matrix(runif(200), 100)
y = matrix_to_tuples(x)
kd_sort(y, inplace = TRUE)
y[kd_nearest_neighbor(y, c(1/2, 1/2)),]
kd_nearest_neighbors(y, c(1/2, 1/2), 3)
y[kd_nn_indices(y, c(1/2, 1/2), 5),]
}
}
